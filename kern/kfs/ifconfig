#!/bin/ash

# known good.
hossinMAC=00241d1054e1
c89MAC=001e67652333
c99MAC=001e67c2f479
altdraMAC=525400b0c2ec
qemuMAC=525400123456
tower1MAC=00032d196d88
tower2MAC=00032d196ddd
tower3MAC=00032d196d46
tower4MAC=00032d196db0
tower5MAC=00032d196daa

MAC=`cat '#ether/ether0/addr'`

#bind -a '#ip' /net
#bind -a '#ether.0' /net
#cat /net/ipifc/clone
## bind the ether0 to it
#echo 'bind ether /net/ether0' > /net/ipifc/0/ctl
#exit

# ifconfig it

export cputype=amd64
export objtype=$cputype
export service=cpu
export authid=bootes
export rootdir=/root
export rootspec=''
export rootsrv=boot

NIC="0"
#authentication='nvram=/boot/adm/nvram auth/factotum -sfactotum -S'      # -a ...
# test xyzip=(0 0 0 104.9.33)
# test fsaddr='tcp!135.$xyzip(4)^!564'
# (me network server server-addr
# wrong addresses.

# qemu is the default
me=10.0.2.15
mask=255.255.255.0
# brho: i don't know what exactly 'remote' is supposed to be, but that is
# the third argument processed by adding to an ipifc.  if we pass nothing,
# it'll build 'remote' by masking me & mask.
remote=10.0.2.0
route=10.0.2.2

if [ "$MAC" = "$qemuMAC" ]
then
    echo "Welcome to QEMU!"
fi

# the tower of ... tower
# all defaults are fine.
if [ "$MAC" = "$tower1MAC" ]
then
    me=10.0.2.15
fi
if [ "$MAC" = "$tower2MAC" ]
then
    me=10.0.2.16
fi
if [ "$MAC" = "$tower3MAC" ]
then
    me=10.0.2.17
fi
if [ "$MAC" = "$tower4MAC" ]
then
    me=10.0.2.18
fi
if [ "$MAC" = "$tower5MAC" ]
then
    me=10.0.2.19
fi

if [ "$MAC" = "$c89MAC" ]
then
	# c89's config.  use c96 for eth0 (.196).
	# $ cat /9/net/ipifc/clone (get e.g. 2)
	# $ echo "add 169.229.49.196 255.255.255.0" > /9/net/ipifc/2/ctl
	me=169.229.49.196
	mask=255.255.255.0
	remote=169.229.49.0
	route=169.229.49.1
	# the i350 NIC that is plugged in is the first NIC
	NIC="0"
fi

if [ "$MAC" = "$c99MAC" ]
then
	# c99's config.  use c95 for eth0 (.195).
	# $ cat /9/net/ipifc/clone (get e.g. 2)
	# $ echo "add 169.229.49.195 255.255.255.0" > /9/net/ipifc/2/ctl
	me=169.229.49.195
	mask=255.255.255.0
	remote=169.229.49.0
	route=169.229.49.1
	# the i350 NIC that is plugged in is the first NIC
	NIC="0"
fi

if [ "$MAC" = "$altdraMAC" ]
then
	# yuzhu's soda hall bridged vm
	me=128.32.37.37
	mask=255.255.255.0
	remote=128.32.37.0
	route=128.32.37.1
fi

if [ "$MAC" = "$hossinMAC" ]
then
	# brho's soda hall desktop
	me=128.32.37.46
	mask=255.255.255.0
	remote=128.32.37.0
	route=128.32.37.1
fi
#
# Post the read-only filesystem in #s/$beetroot
# and mount it on /boot so the commands in /boot/$cputype/bin
# are available to create the namespace (namespaces like to
# mount #s/boot on / and that should not be the read-only
# filesystem).
# Must set hostowner to be that of the owner of the nvram file
# before paqfs starts otherwise factotum will not be able to
# open it.
#
#/boot/echo -n sys > '#c/hostowner'
#/boot/paqfs -p -S $beetroot -m /boot -q /boot/$beetroot
#cd /boot/$cputype/bin
bind -b '#cons' /dev
#bind '#d' /fd
#bind -c '#e' /env
bind -b '#proc' /proc
#bind -b -c '#srv' /srv
bind -b '#srv' /srv

#
# Configure the networks.
#
bind -a '#ip' /net
bind -a \#ether.$NIC /net

# note: dhcp is possible, just not done yet.
#get an instance of a network stack
i=`cat /net/ipifc/clone`
# bind the ether0 to it
# the kernel sets errno, though it doesn't return -1 or anything.  but our bb
# hacks doesn't know any better, and echo will think it was an error
echo "bind ether /net/ether$NIC " > /net/ipifc/$i/ctl 2> /dev/null
# ifconfig it
echo "add $me $mask $remote" > /net/ipifc/$i/ctl
echo "add 0 0 $route" > /net/iproute
echo I am $me, default route $route

i=`cat /net/ipifc/clone`
echo "bind loopback /dev/null " > /net/ipifc/$i/ctl
echo "add 127.0.0.1 255.0.0.0 127.0.0.0 " > /net/ipifc/$i/ctl

cs&
if [ ! -e "#srv/cs" ]
then
	echo "cs hasn't created #srv/cs yet, sleeping until it does..."
	until [ -e "#srv/cs" ]
	do
		usleep 1000
	done
fi
mount -a \#srv/cs /net

# this is noisy, so it is off by default.
#echo debug > /net/cs

bind -a \#kprof /prof/

echo "ifconfig complete"
